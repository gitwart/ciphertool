? .vimrc
? Release.notes
? Release.todo
? UI2.0
? autom4te.cache
? bifid_display.tpj
? build
? dictionary.tpj
? diff.log
? dumproute.txt
? hillclimb.tpj
? hillclimb.txt
? key_descriptions.txt
? maxrunkey.tpj
? out.html
? patsplit.c
? patternmatch.tpj
? runkey.c
? score.txt
? soaptest
? status.log
? testroute
? tetra.txt
? triwordtreeScore.c
? wordlist
? data/ja2004.tcl
? progs/.vimrc
? progs/bazexample
? progs/doprog
? progs/dosolver
? progs/gromarksolve
? progs/hillclimbstats
? progs/k2msearch
? progs/k3board
? progs/k3board.tcl
? progs/kshunt2
? progs/patbrute
? progs/patbrute2
? progs/patternmatch.tcl
? progs/ptval
? progs/quag1stats
? progs/quag1topat
? progs/quag2keysearch
? progs/rechillclimb.tcl
? progs/scoredata
? progs/testscore
? tests/hillclimb.test
Index: ChangeLog
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/ChangeLog,v
retrieving revision 1.138
diff -u -r1.138 ChangeLog
--- ChangeLog	17 Mar 2008 01:07:44 -0000	1.138
+++ ChangeLog	31 Mar 2008 19:34:29 -0000
@@ -1,3 +1,25 @@
+    * Makefile.in:  Add lethist and solvemysz utilities.  Added quagmire
+      cipher type.
+    * tests/quagmire.test:
+    * quagmire.c:  Add initial support for decoding quagmire I and II ciphers.
+    * configure:
+    * configure.in:  Re-enable check for getenv() so that we can use
+      the CIPHERTOOL_DICTIONARY environment variable to specify the
+      dictionary location.
+    * hillclimbCiphers.tcl:  Add getK1FullKeyList for single-word key
+      restores.
+    * progs/hillclimb:  Use the cipher-specific restore procedure
+    * progs/slidesolve:  Add -scoretype command line argument
+    * library/utils.tcl:  remove function that saves in the old format
+    * library/dictionary.tcl:  Fix bug that would throw an error if
+      lookupByPattern found no matches.
+    * hillclimb.c:
+    * cipherInit.c: Add method for swapping letters in the same keysquare
+      row/column
+    * tests/dictionary.test:
+    * dictionaryCmds.c:  Throw an error if a word with the wrong length is found
+      in a dictionary file.
+
 Sun Mar 16 17:59:09 PDT 2008 wart@kobold.org
     * progs/keysearch:
     * progs/keysearch:
Index: TODO
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/TODO,v
retrieving revision 1.41
diff -u -r1.41 TODO
--- TODO	17 Mar 2008 06:18:23 -0000	1.41
+++ TODO	31 Mar 2008 19:34:29 -0000
@@ -4,6 +4,16 @@
 1.6.3
 =================
 
+Implement lookupByPattern in C using CadenusGenerateKeyOrder as a template
+
+Fill out quagmire tests for more error conditions
+
+Check for result of Tcl_SplitList() not being freed
+    Tcl_Free((char *) argv);
+
+quag2keysearch gives a confusing error if no solution is found (such as
+    using a vertical keyword length that does not match the cipher period)
+
 Add tests for encoding bad input
 
 Validate cadenus key order for restore and encoding commands
@@ -15,12 +25,15 @@
 
 Modify new word splitter to ignore numbers
 
+Allow invalid words in new word splitter
+    see test wordtree-4.5
+
 slidesolve does not convert all ciphertext to plaintext
     ma2008:e11 (period 7, type vigenere)
 
-Remove references to obsolete 'CipherUtil::readSavedCipher' procedure
-    patsplit
-    ptval
+(done) Remove references to obsolete 'CipherUtil::readSavedCipher' procedure
+
+Modify ptval to use score initialization code as found in csolve
 
 Fix the usage info for the "key" command
     [key foo] does not show all possible subcommands (convert)
Index: cipher_soap.tcl
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/cipher_soap.tcl,v
retrieving revision 1.1
diff -u -r1.1 cipher_soap.tcl
--- cipher_soap.tcl	7 Nov 2004 04:29:46 -0000	1.1
+++ cipher_soap.tcl	31 Mar 2008 19:34:29 -0000
@@ -12,6 +12,11 @@
        return english
    }
 
+   proc getCipherTypes {} {
+       return [cipher types]
+   }
+
+   SOAP::export getCipherTypes
    SOAP::export getLanguages
 }
 
Index: keyphrase.c
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/keyphrase.c,v
retrieving revision 1.3
diff -u -r1.3 keyphrase.c
--- keyphrase.c	5 Aug 2003 13:11:52 -0000	1.3
+++ keyphrase.c	31 Mar 2008 19:34:30 -0000
@@ -66,6 +66,7 @@
     KeyphraseLocateTip,	/* locate proc */
     KeyphraseSubstitute,/* sub proc */
     KeyphraseUndo,	/* undo proc */
+    NULL,		/* encode proc */
     (CipherType *)NULL	/* next cipher type */
 };
 
Index: railfence.c
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/railfence.c,v
retrieving revision 1.6
diff -u -r1.6 railfence.c
--- railfence.c	15 Mar 2004 22:05:05 -0000	1.6
+++ railfence.c	31 Mar 2008 19:34:31 -0000
@@ -53,6 +53,7 @@
 static int RailfenceMoveStart	_ANSI_ARGS_((Tcl_Interp *, CipherItem *,
 	    			int, int));
 static void RailfenceSetKey	_ANSI_ARGS_((CipherItem *, int, int));
+static char *RailfenceTransform	_ANSI_ARGS_((CipherItem *, char *, int));
 
 typedef struct RailfenceItem {
     CipherItem header;
@@ -74,9 +75,10 @@
     SetRailfence,	/* show ciphertext proc */
     SolveRailfence,	/* solve cipher proc */
     RestoreRailfence,	/* restore proc */
-    RailfenceLocateTip,/* locate proc */
+    RailfenceLocateTip,	/* locate proc */
     RailfenceSubstitute,	/* sub proc */
     RailfenceUndo,	/* undo proc */
+    NULL,		/* encode proc */
     (CipherType *)NULL	/* next cipher type */
 };
 
@@ -214,6 +216,11 @@
 static char *
 GetRailfence(Tcl_Interp *interp, CipherItem *itemPtr)
 {
+    return RailfenceTransform(itemPtr, itemPtr->ciphertext, DECODE);
+}
+
+static char *
+RailfenceTransform(CipherItem *itemPtr, char *text, int mode) {
     RailfenceItem *railPtr = (RailfenceItem *)itemPtr;
     char	*c;
     int		i, col, pos;
@@ -278,7 +285,11 @@
 		fprintf(stderr, "Fatal indexing error!\n");
 		abort();
 	    }
-	    result[newIndex] = railPtr->header.ciphertext[oldIndex];
+	    if (mode == DECODE) {
+		result[newIndex] = text[oldIndex];
+	    } else {
+		result[oldIndex] = text[newIndex];
+	    }
 	}
 	orderArr[newCol]++;
     }
@@ -408,7 +419,8 @@
 	pt = GetRailfence(interp, itemPtr);
 
 	if (pt) {
-	    if (DefaultScoreValue(interp, pt, &value) != TCL_OK) {
+	    if (DefaultScoreValue(interp, (unsigned char *)pt, &value)
+                    != TCL_OK) {
 		return TCL_ERROR;
 	    }
 	    if (value > maxValue) {
@@ -431,7 +443,8 @@
 	pt = GetRailfence(interp, itemPtr);
 
 	if (pt) {
-	    if (DefaultScoreValue(interp, pt, &value) != TCL_OK) {
+	    if (DefaultScoreValue(interp, (unsigned char *)pt, &value)
+                    != TCL_OK) {
 		return TCL_ERROR;
 	    }
 	    if (value > maxValue) {
@@ -883,3 +896,55 @@
 
     return TCL_OK;
 }
+
+static int
+EncodeMyszcowski(Tcl_Interp *interp, CipherItem *itemPtr, char *pt, char *key) {
+    char *ct = (char *)NULL;
+    int count;
+    char **argv;
+
+    if (Tcl_SplitList(interp, key, &count, &argv) != TCL_OK) {
+	return TCL_ERROR;
+    }
+
+    if (count != 1) {
+	ckfree((char *)argv);
+	Tcl_AppendResult(interp, "Invalid number of items in encoding key '",
+	      key, "'.  Should have found 1.", (char *)NULL);
+	return TCL_ERROR;
+    }
+
+    if (strlen(argv[0]) != itemPtr->period) {
+	Tcl_SetResult(interp,
+		"Length of key does not match the period.", TCL_STATIC);
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+
+    if ((itemPtr->typePtr->setctProc)(interp, itemPtr, pt) != TCL_OK) {
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+    if ((itemPtr->typePtr->restoreProc)(interp, itemPtr, argv[0], (char *)NULL) != TCL_OK) {
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+    ct = RailfenceTransform(itemPtr, itemPtr->ciphertext, ENCODE);
+    if (ct == (char *)NULL) {
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+    if ((itemPtr->typePtr->setctProc)(interp, itemPtr, ct) != TCL_OK) {
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+    if ((itemPtr->typePtr->restoreProc)(interp, itemPtr, argv[0], (char *)NULL) != TCL_OK) {
+	ckfree((char *)argv);
+	return TCL_ERROR;
+    }
+
+    Tcl_SetResult(interp, ct, TCL_DYNAMIC);
+    ckfree((char *)argv);
+
+    return TCL_OK;
+}
Index: solver.c
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/solver.c,v
retrieving revision 1.4
diff -u -r1.4 solver.c
--- solver.c	3 May 2004 02:29:58 -0000	1.4
+++ solver.c	31 Mar 2008 19:34:31 -0000
@@ -39,7 +39,7 @@
 #include <ctype.h>
 #include <solver.h>
 
-#define DICT_DIR   "/home/wart/lib/dict"
+#define DICT_DIR   "/home/wart/share/dict"
 
 /* Global variables */
 
Index: library/hillclimbCiphers.tcl
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/library/hillclimbCiphers.tcl,v
retrieving revision 1.13
diff -u -r1.13 hillclimbCiphers.tcl
--- library/hillclimbCiphers.tcl	17 Mar 2008 00:02:24 -0000	1.13
+++ library/hillclimbCiphers.tcl	31 Mar 2008 19:34:32 -0000
@@ -46,9 +46,9 @@
     set fullKeyListFromType(bigbifid)	Hillclimb::get6x6KeysquareFullKeyList
     set fullKeyListFromType(bifid)	Hillclimb::getKeysquareFullKeyList
     set fullKeyListFromType(digrafid)	Hillclimb::getDigrafidFullKeyList
-    set fullKeyListFromType(fmorse)	Hillclimb::getAristocratFullKeyList
+    set fullKeyListFromType(fmorse)	Hillclimb::getK1FullKeyList
     set fullKeyListFromType(foursquare)	Hillclimb::getTwosquareFullKeyList
-    set fullKeyListFromType(gromark)	Hillclimb::getAristocratFullKeyList
+    set fullKeyListFromType(gromark)	Hillclimb::getK1FullKeyList
     set fullKeyListFromType(phillips)	Hillclimb::getKeysquareFullKeyList
     set fullKeyListFromType(playfair)	Hillclimb::getKeysquareFullKeyList
     set fullKeyListFromType(bigplayfair) Hillclimb::get6x6KeysquareFullKeyList
@@ -83,7 +83,7 @@
     set swapKeyProc(fmorse)	Hillclimb::swapGenericKey
     set swapKeyProc(foursquare)	Hillclimb::swapTwosquareKey
     set swapKeyProc(gromark)	Hillclimb::swapGenericKey
-    set swapKeyProc(phillips)	Hillclimb::swapGenericKey
+    set swapKeyProc(phillips)	Hillclimb::swapKeysquareKey
     set swapKeyProc(playfair)	Hillclimb::swapGenericKey
     set swapKeyProc(bigplayfair) Hillclimb::swapGenericKey
     set swapKeyProc(ragbaby)	Hillclimb::swapGenericKey
@@ -315,6 +315,33 @@
     return $fullKeyList
 }
 
+# Hillclimb::getK1FullKeyList
+#
+#	Generate a list of possible keys from a keyword.
+#
+# Arguments:
+#
+#	keyword		Keyword used to generate the key.
+#
+# Result:
+#	A full keyed alphabet.
+
+proc Hillclimb::getK1FullKeyList {keyword} {
+    set fullKeyList {}
+    #set fixedKey [key generate -k1 $keyword]
+    foreach key [key generate -k1list $keyword] {
+	# K1 key
+	lappend fullKeyList $key
+	#lappend fullKeyList $key
+	# K2 key
+	#lappend fullKeyList [list $key abcdefghijklmnopqrstuvwxyz]
+	# K3 key
+	#lappend fullKeyList [list $fixedKey $key]
+    }
+
+    return $fullKeyList
+}
+
 
 # Hillclimb::getTwosquareFullKeyList
 #
Index: progs/kshunt
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/progs/kshunt,v
retrieving revision 1.9
diff -u -r1.9 kshunt
--- progs/kshunt	5 Mar 2008 03:54:58 -0000	1.9
+++ progs/kshunt	31 Mar 2008 19:34:32 -0000
@@ -60,12 +60,11 @@
 	-ct [string repeat a $cipherParms(keylength)] \
 	-period $cipherParms(keyperiod)]
 
-set targetKey 	 "??????"
-append targetKey "?????a"
-append targetKey "??b???"
-append targetKey "??????"
-append targetKey "k???p?"
-append targetKey "??w???"
+set targetKey 	 "downt"
+append targetKey "?????"
+append targetKey "g??s?"
+append targetKey "?x???"
+append targetKey "??i?a"
 set cipherParms(targetKey) $targetKey
 
 proc bestkey {cipherProc keywordList countVar {maxValue 0}} {
@@ -112,55 +111,36 @@
 		set result 0
 		set pt [$cipherParms(keycipher) cget -pt]
 		foreach row [$cipherParms(keycipher) cget -ptblock] {
-		    if {[string first k $row] != -1 \
-			&& [string first h $row] != -1 \
-			&& [string first n $row] != -1 \
-			&& [string first g $row] != -1} {
-			incr result
-		    }
-		    if {[string first s $row] != -1 \
-			&& [string first i $row] != -1 \
+		    if {[string first d $row] != -1 \
+			&& [string first o $row] != -1 \
+			&& [string first w $row] != -1 \
 			&& [string first t $row] != -1 \
-			&& [string first e $row] != -1} {
+			&& [string first n $row] != -1} {
 			incr result
 		    }
-		    if {[string first r $row] != -1 \
-			&& [string first u $row] != -1 \
-			&& [string first q $row] != -1 \
-			&& [string first o $row] != -1} {
+		    if {[string first s $row] != -1 \
+			&& [string first g $row] != -1} {
 			incr result
 		    }
 		    if {[string first a $row] != -1 \
-			&& [string first f $row] != -1} {
-			incr result
-		    }
-		    if {[string first x $row] != -1 \
-			&& [string first y $row] != -1} {
-			incr result
-		    }
-		    if {[string first w $row] != -1 \
-			&& [string first z $row] != -1} {
-			incr result
-		    }
-		    if {[string first b $row] != -1 \
-			&& [string first d $row] != -1} {
+			&& [string first i $row] != -1} {
 			incr result
 		    }
 		}
-		if {$result == 7} {
+		if {$result == 3} {
 		    foreach row [$cipherParms(keycipher) cget -ptblock] {
 			puts "#\t[string toupper $row]"
 		    }
 		    puts "# $count, $keyword"
 		    puts ""
 		}
-		if {[string match $cipherParms(targetKey) \
-			[$cipherParms(keycipher) cget -pt]]} {
-		    foreach row [$cipherParms(keycipher) cget -ptblock] {
-			puts "#\t[string toupper $row]"
-		    }
-		    puts "# $count, $keyword" #		    puts ""
-		}
+#		if {[string match $cipherParms(targetKey) \
+#			[$cipherParms(keycipher) cget -pt]]} {
+#		    foreach row [$cipherParms(keycipher) cget -ptblock] {
+#			puts "#\t[string toupper $row]"
+#		    }
+#		    puts "# $count, $keyword" #		    puts ""
+#		}
 	    }
 	} else {
 	    #puts "Got error while creating keylist:  $err"
Index: tests/wordtree.test
===================================================================
RCS file: /cvsroot/ciphertool/ciphertool/tests/wordtree.test,v
retrieving revision 1.5
diff -u -r1.5 wordtree.test
--- tests/wordtree.test	17 Mar 2008 00:09:48 -0000	1.5
+++ tests/wordtree.test	31 Mar 2008 19:34:33 -0000
@@ -239,6 +239,19 @@
     set result
 } {the quick brownfox}
 
+test wordtree-4.5 {Find the best word splitting, some words not valid} {
+    wordtree add the
+    wordtree add quick
+    wordtree add fox
+    wordtree add brown
+
+    set result [wordtree splitbest "theqbrownfox"]
+
+    wordtree delete
+
+    set result
+} {the q brown fox}
+
 test wordtree-5.1 {Test for empty tree} {
     set result [wordtree isempty]
 } {1}
